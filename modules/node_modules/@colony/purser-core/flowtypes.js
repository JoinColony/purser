/* @flow */

import { Provider } from 'ethers/providers';

export type DerivationPathObjectType = {|
  purpose?: number,
  coinType?: number,
  account?: number,
  change?: number,
  addressIndex?: number,
|};

export type DerivationPathDefaultType = {
  HEADER_KEY: string,
  PURPOSE: number,
  COIN_MAINNET: number,
  COIN_TESTNET: number,
  ACCOUNT: number,
  CHANGE: number,
  INDEX: number,
  DELIMITER: string,
};

export type TransactionObjectType = {
  chainId: number,
  gasPrice: string,
  gasLimit: string,
  nonce: number,
  to?: string,
  value: string,
  inputData: string,
};

export type WalletObjectType = {
  address: string,
  otherAddresses?: Array<string>,
  defaultGasLimit?: number,
  keystore?: Promise<string>,
  mnemonic?: string,
  path?: string,
  +derivationPath?: Promise<string>,
  privateKey?: string,
  +publicKey?: Promise<string>,
  sign: (...*) => Promise<TransactionObjectType>,
};

export type MessageObjectType = {
  message: string,
};

export type WalletArgumentsType = {
  address: string,
  /*
   * Used to select the address index from the hardware wallet
   */
  addressCount?: number,
  privateKey?: string,
  mnemonic?: string,
  originalMnemonic?: string,
  path?: string,
  keystore?: string,
  entropy?: Uint8Array,
  password?: string,
  chainId?: number,
  sign?: () => {},
  signMessage: (MessageObjectType) => Promise<string>,
};

export type MessageVerificationObjectType = {|
  message: string,
  signature: string,
|};

/*
 * Types used for modules exports
 */
export type LibraryExportType = {
  wallets: Object,
  about: {
    name: string,
    version: string,
    environment: string,
  },
  utils: Object,
  debug?: Object,
};

export type GenericClassArgumentsType = {
  publicKey?: string,
  chainCode?: string,
  rootDerivationPath: string,
  addressCount?: number,
  chainId?: number,
};

export type TransactionResponseType = {
  /*
   * Only available for mined transactions
   */
  blockHash?: string,
  blockNumber?: number,
  timestamp?: number,
  /*
   * Exactly one of these will be present (send vs. deploy contract)
   * They will always be a properly formatted checksum address
   */
  creates?: string,
  to?: string,
  hash: string,
  data: string,
  from: string,
  gasLimit: number,
  gasPrice: number,
  nonce: number,
  value: number,
  chainId: number,
  /*
   * The signature of the transaction (TestRPC may fail to include these)
   */
  r?: string,
  s?: string,
  v?: number,
  /*
   * The raw transaction (TestRPC may be missing this)
   */
  raw?: string
};

export type PurserSignerConstructorArguments = {
  purserWalletInstance: WalletArgumentsType,
  provider: Provider,
};
